module ReactiveMarkup.SimpleEvents where

import Data.IORef
import qualified Data.IntMap as IM

data Dynamic a = Dynamic
  { registerHandler :: (a -> IO ()) -> IO (IO ()),
    currentValue :: IO a
  }

newtype Trigger a = Trigger {triggerEvent :: a -> IO ()}

newDynamic :: a -> IO (Dynamic a, Trigger a)
newDynamic a = do
  valueRef <- newIORef a
  listenersRef <- newIORef $ IM.empty
  let dyn =
        Dynamic
          ( \f -> atomicModifyIORef listenersRef $ \listeners ->
              ( IM.insert (IM.size listeners) f listeners,
                modifyIORef listenersRef $ \l -> IM.delete (IM.size l) l
              )
          )
          (readIORef valueRef)
      trigger a = (readIORef listenersRef >>= traverse ($a)) *> pure ()
  pure $ (dyn, Trigger trigger)

-- filterEqual :: Equal a => Dynamic a -> Dynamic a
-- filterEqual (Dynamic reg val) = Dynamic adaptedReg val


instance Functor Dynamic where
  fmap f (Dynamic reg get) = Dynamic (reg . (. f)) (f <$> get)

instance Applicative Dynamic where
  pure a = Dynamic (\_ -> pure (pure ())) (pure a)
  (Dynamic register1 value1) <*> (Dynamic register2 value2) = Dynamic applicativeRegister (value1 <*> value2)
    where
      applicativeRegister handle = do
        unReg1 <- register1 $ \f -> (pure f <*> value2) >>= handle
        unReg2 <- register2 $ \a -> (value1 <*> pure a) >>= handle
        pure $ unReg1 *> unReg2
