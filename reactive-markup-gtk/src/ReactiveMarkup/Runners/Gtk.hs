module ReactiveMarkup.Runners.Gtk where

import qualified GI.Gtk as Gtk
import qualified GI.Pango as P
import Data.IORef

import ReactiveMarkup.Markup
import ReactiveMarkup.Elements.Settings
import ReactiveMarkup.Elements.Basic
import ReactiveMarkup.SimpleEvents
import Control.Monad (join)
import qualified Data.Text as T


-- | Basic `Runner` for GTK 3. It is definitely not optimal, but is sufficient as demontration.
gtkRunner :: Runner [Label, List, Button, DynamicState, DynamicMarkup] IO (Gtk.Widget)
gtkRunner = emptyRunner
  |-> (\(Label styles t) _ _ -> do
    label <- Gtk.new Gtk.Label [#label Gtk.:= t]
    attrList <- P.attrListNew
    let sizeAttribute = 
          P.attrSizeNew $ case labelGetSize styles of
            Smallest -> P.SCALE * 9
            Smaller -> P.SCALE * 11
            Regular -> P.SCALE * 14
            Bigger -> P.SCALE * 17
            Biggest -> P.SCALE * 20
        boldAttribute = 
          P.attrWeightNew $ case labelGetBold styles of
            Bold -> P.WeightBold
            NotBold -> P.WeightNormal
        italicAttribute = 
          P.attrStyleNew $ case labelGetItalic styles of
            Italic -> P.StyleItalic
            NotItalic -> P.StyleNormal
    sizeAttribute >>= P.attrListInsert attrList
    boldAttribute >>= P.attrListInsert attrList
    italicAttribute >>= P.attrListInsert attrList
    Gtk.labelSetAttributes label $ Just attrList
    Gtk.toWidget label
    )
  |-> (\(List style markups) runner handleEvent -> do 
        boxLayout <- Gtk.new Gtk.Box []
        sequenceA $ (\markup -> runMarkup runner handleEvent markup >>= #add boxLayout) <$> markups
        Gtk.set boxLayout $ case listGetOrientation style of
          Horizontal -> [#orientation Gtk.:= Gtk.OrientationHorizontal]
          Vertical -> [#orientation Gtk.:= Gtk.OrientationVertical]
        Gtk.toWidget boxLayout
      )
  |-> (\(Button text) _ handleEvent -> do
        button <- Gtk.new Gtk.Button [#label Gtk.:=text]
        Gtk.on button #clicked (handleEvent Click)
        Gtk.toWidget button
    )
  |-> (\(DynamicState state mapEvent generateMarkup) childRunner handleOuterEvent -> do
    (dynamicState, updateState) <- newDynamic state
    let handleInnerEvent innerEvent = do
          state <- current $ toBehavior dynamicState
          let (changedState, outerEvent) = mapEvent state innerEvent
          maybe mempty (triggerEvent updateState) changedState
          maybe mempty handleOuterEvent outerEvent
    runMarkup childRunner handleInnerEvent $ generateMarkup dynamicState
    )
  |-> (\(DynamicMarkup dynamicState generateMarkup) childRunner handleEvent -> do
    boxLayout <- Gtk.new Gtk.Box [#orientation Gtk.:= Gtk.OrientationVertical]
    state <- current $ toBehavior dynamicState
    cleanUpRef <- newIORef mempty
    let setWidget widget = do
          cleanUp <- join $ readIORef cleanUpRef
          writeIORef cleanUpRef (#remove boxLayout widget)
          #add boxLayout widget
          #showAll widget
        generateWidget state = runMarkup childRunner handleEvent $ generateMarkup state
    
    unregisterWidgetUpdate <- reactimate (toEvent dynamicState) $ simpleEventHandler $ \newState -> do
      generateWidget newState >>= setWidget

    generateWidget state >>= setWidget
    widget <- Gtk.toWidget boxLayout
    Gtk.on widget #destroy (liftES unregisterWidgetUpdate)
    pure widget
    )

-- | Quick setup for GTK to display a widget generated by 'runMarkup' in combination with 'gtkRunner'.
--
-- Example: main = basicGtkSetup "MyWindowName" $ runMarkup gtkRunner (\_ -> pure ()) myMarkup
basicGtkSetup :: T.Text -> IO Gtk.Widget -> IO ()
basicGtkSetup windowTitle widget = do
  Gtk.init Nothing
  win <- Gtk.new Gtk.Window [#title Gtk.:= windowTitle]
  Gtk.on win #destroy Gtk.mainQuit
  widget >>= #add win
  #showAll win
  Gtk.main
